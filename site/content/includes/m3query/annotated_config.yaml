# The server listen address
listenAddress: <url>

# Metrics configuration
# TODO: Which is what?
metrics:
  # Scope of metrics root
  # TODO: Again, which is?
  scope:
    # Prefix prepended to metrics collected
    prefix: <string>
    # Reporting frequendy of metrics collected
    reportingInterval: <duration>
    # Tags shared by metrics collected
    tags: <map of strings>
  # Configuration for a Prometheus reporter (if used)
  prometheus:
    # Metrics collection endpoint for application
    # Default = "/metrics"
    handlerPath: <string>
    # Listen address for metrics
    # Default = "0.0.0.0:7203"
    listenAddress: <url>
    # Metric sanitization type, valid options: [none, m3, prometheus]
    # Default = "none"
    sanitization: <string>
  # Sampling rate for metrics. min=0.0, max=1.0
  # TODO: What does this mean exactly?
  samplingRate: <float>
  # Enable Go runtime metrics, valid options: [none, simple, moderate, detailed]
  # See https://github.com/m3db/m3/blob/master/src/x/instrument/extended.go#L39:L64 for more details
  extended: <string>

# Logging configuration
# TODO: More detail than this 
# https://github.com/m3db/m3/blob/9f129cf9f16430cc5a399f60aa5684fb72b55bb5/src/cmd/services/m3query/config/config.go#L116
# Configuration for logging.
logging:
  # Log file location
  file: <string>
  # Error logging level
  level: <string>
  # TODO: ??
  fields:

# Enables tracing, if nothing configured, tracing is disabled
tracing:
  # Name for tracing service
  serviceName: <string>
  # Tracing backen to use, valid options: [jaeger, lightstep]
  backend: <string>
  # If using Jaeger, options to send to tracing backend
  jaeger:
  # If using Lightstep, options to send to tracing backend
  lightstep:

clusters:
  - namespaces:
      - namespace: default
        type: unaggregated
        retention: 48h
    client:
      config:
        service:
          # TODO: ?
          env: <string>
          # Availability zone, valid options: [user-defined, embedded]
          zone: <string>
          # TODO: ??
          service: m3db
          # Directory to store cached etcd data
          cacheDir: <string>
          # Identify the etcd hosts this node should connect to
          etcdClusters:
            # TODO: Confusing, if you use embedded, why do you still need endpoints?
            # TODO: Embedded vs seed nodes embedded??
            # Availability zone, valid options: [user-defined, embedded]
            - zone: <string>
              # Member nodes of the etcd cluster, in form url:port
              endpoints:
                - <url>
        # Seed node configuration
        seedNodes:
          rootDir:
          initialAdvertisePeerUrls:
          advertiseClientUrls: <array_of_strings>
          listenPeerUrls: <array_of_strings>
          listenClientUrls: <array_of_strings>
          # A seed node for the cluster
          initialCluster:
            # Identifier for node
            - hostID: <string>
              # URL of node
              endpoint: <url>
              # TODO: ?
              clusterState: <string>
          # Seed node security configuration
          # TODO: Specifics
          clientTransportSecurity:
            caFile: <string>
            certFile: <string>
            keyFile: <string>
            trustedCaFile: <string>
            clientCertAuth: <bool>
            autoTls: <bool>
          # Seed node security configuration
          # TODO: Specifics
          peerTransportSecurity:
            caFile: <string>
            certFile: <string>
            keyFile: <string>
            trustedCaFile: <string>
            clientCertAuth: <bool>
            autoTls: <bool>
      # The consistency level for writing to a cluster, valid options: [none, one, majority, all]
      writeConsistencyLevel: <string>
      # The consistency level for reading from a cluster, valid options: [none, one, unstrict_majority, majority, unstrict_all, all]
      readConsistencyLevel: <string>
      # The timeout for writing data
      # TODO: Defaults?
      writeTimeout: <duration>
      # The fetch timeout for any given query
      # Range =  30s to 5m
      fetchTimeout: <duration>
      # The cluster connect timeout    
      connectTimeout: <duration>
      # Configuration for retrying write operations
      writeRetry:
        initialBackoff: <duration>
        # Factor for exponential backoff
        backoffFactor: <float>
        # Maximum backoff time
        maxBackoff: <duration>
        # Maximum retry attempts
        maxRetries: <int>
        # Add randomness to wait intervals
        jitter: <bool>
      # Configuration for retrying fetch operations
      # TODO: Query?
      fetchRetry:
        initialBackoff: <duration>
        # Factor for exponential backoff
        backoffFactor: <float>
        # Maximum backoff time
        maxBackoff: <duration>
        # Maximum retry attempts
        maxRetries: <int>
        # Add randomness to wait intervals
        jitter: <bool>
      # The amount of times a background check fails before a connection is taken out of consideration
      backgroundHealthCheckFailLimit: <int>
      # The factor of the host connect time when sleeping between a failed health check and the next check
      backgroundHealthCheckFailThrottleFactor: <float>

# Local embedded configuration if running embedded coordinator
local:
  # Describes the namespaces in a static cluster
  namespaces:
    # Name for the namespace
    namespace: <string>
    # The type of values stored by the namespace, current, valid options: [unaggregated, aggregated]
    type: <string>
    retention: <duration>
    resolution: <duration>
    downsample:

# Configuration for the placemement, namespaces and database management endpoints.
clusterManagement:
  # etcd client configuration
  etcd:
    # TODO: ?
    env: default_env
    # Availability zone, valid options: [user-defined, embedded]
    zone: <string>
    # TODO: ??
    service: m3db
    # Directory to store cached etcd data
    cacheDir: <string>
    # Identify the etcd hosts this node should connect to
    # TODO: Fill this in
    etcdClusters:
    # TODO: What is this?
    m3sd:
      initTimeout: <duration>
    # The revision that watch requests start from
    watchWithRevision: <int>
    # Changes permissions and mode of cache directory
    newDirectoryMode: <string>
    # Configuration for retrying connection operations
    retry:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Add randomness to wait intervals
      jitter: <bool>
    # The timeout for etcd requests
    requestTimeout: <duration>
    # The timeout for a watchChan initialization
    watchChanInitTimeout: <duration>
    # Frequency to check if a watch chan is no longer subscribed and should be closed
    watchChanCheckInterval: <duration>
    # The delay before resetting the etcd watch chan
    watchChanResetInterval: <duration>

# TODO:
filter:

# TODO:
rpc:

# TODO:
backend:

# The worker pool policy for read requests
readWorkerPoolPolicy:
  # Worker pool automatically grows to capacity
  grow: <bool>
  # Static pool size, or initial size for dynamically growing pools
  size: <int>

# The worker pool policy for write requests
writeWorkerPoolPolicy:
  # Worker pool automatically grows to capacity
  grow: <bool>
  # Static pool size, or initial size for dynamically growing pools
  size: <int>

# Write forwarding options
# TODO: Which is?
writeForwarding:
  # Forwarding options for prometheus write handler
  promRemoteWrite:
    maxConcurrency: <int>
    timeout: <duration>
    # Configuration for retrying connection operations
    retry:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Add randomness to wait intervals
      jitter: <bool>
    # Prometheus write handler forwarder target
    targets:
      # URL of the target to send to
      url: <string>
      # Method defaults to POST if not set
      method: <string>
      # Headers to send with requests to the target
      headers: <map of strings>

# How to downsample metrics
downsample:
  # The configuration for the downsampler matcher
  matcher:
  # Downsample rules which overrides any rules set in the KV store
  # TODO: KV store? etcd?
  rules:
  # Downsample remotely by sending values to a remote m3aggregator cluster which forwards the aggregated values to stateless m3coordinator backends
  remoteAggregator:
    # Remote aggregator client
    client:
      # The aggregator client type, valid options: [legacy, m3msg, tcp]
      type: <string>
      # Required configuration if using the m3msg client type
      m3msg:
        producer:
          # Buffer configuration for m3msg client type
          buffer:
            # TODO: Not sure
            onFullStrategy:
            maxBufferSize: <int>
            maxMessageSize: <int>
            closeCheckInterval: <duration>
            dropOldestInterval: <duration>
            scanBatchSize: <int>
            allowedSpilloverRatio: <float>
            #  Cleanup retry configuration
            cleanupRetry:
              initialBackoff: <duration>
              # Factor for exponential backoff
              backoffFactor: <float>
              # Maximum backoff time
              maxBackoff: <duration>
              # Maximum retry attempts
              maxRetries: <int>
              # Add randomness to wait intervals
              jitter: <bool>
          # Writer configuration for m3msg client type
          writer:
            topicName: <string>
            topicServiceOverride:
            topicWatchInitTimeout: <duration>
            # Placement options
            placement:
              allowPartialReplace: <bool>
              allowAllZones: <bool>
              addAllCandidates: <bool>
              isSharded: <bool>
              # TODO: ?
              shardStateMode:
              isMirrored: <bool>
              isStaged: <bool>
              validZone: <string>
            # Override configuration for namespace options
            placementServiceOverride:
              namespaces:
                placement: <string>
                metadata: <string>
            placementWatchInitTimeout: <duration>
            messagePool:
              size: <int>
              # Pool watermark configuration
              watermark:
                # The low watermark to start refilling the pool
                # min=0.0, max=1.0
                low: <float>
                # The high watermark to start refilling the pool
                # min=0.0, max=1.0
                high: <float>
            # Message retry configuration
            messageRetry:
              initialBackoff: <duration>
              # Factor for exponential backoff
              backoffFactor: <float>
              # Maximum backoff time
              maxBackoff: <duration>
              # Maximum retry attempts
              maxRetries: <int>
              # Add randomness to wait intervals
              jitter: <bool>
            messageQueueNewWritesScanInterval: <duration>
            messageQueueFullScanInterval: <int>
            messageQueueScanBatchSize: <int>
            initialAckMapSize: <int>
            closeCheckInterval: <duration>
            # Acknowledging error retry configuration
            ackErrorRetry:
              initialBackoff: <duration>
              # Factor for exponential backoff
              backoffFactor: <float>
              # Maximum backoff time
              maxBackoff: <duration>
              # Maximum retry attempts
              maxRetries: <int>
              # Add randomness to wait intervals
              jitter: <bool>            
            encoder:
              maxMessageSize: <int>
              # Bucketized pool configuration
              bytesPool:
                # Configuration for a bucket in a pool
                buckets:
                  # Number of items in the bucket
                  count: <int>
                  # Capacity of each item in the bucket
                  capacity: <int>
                watermark:
                  # The low watermark to start refilling the pool
                  # min=0.0, max=1.0
                  low: <float>
                  # The high watermark to start refilling the pool
                  # min=0.0, max=1.0
                  high: <float>
            decoder:
              maxMessageSize: <int>
              # Bucketized pool configuration
              bytesPool:
                # Configuration for a bucket in a pool
                buckets:
                  # Number of items in the bucket
                  count: <int>
                  # Capacity of each item in the bucket
                  capacity: <int>
                watermark:
                  # The low watermark to start refilling the pool
                  # min=0.0, max=1.0
                  low: <float>
                  # The high watermark to start refilling the pool
                  # min=0.0, max=1.0
                  high: <float>
            # Connection options
            connection:
              numConnections: <int>
              dialTimeout: <duration>
              writeTimeout: <duration>
              keepAlivePeriod: <duration>
              resetDelay: <duration>
              retry:
                initialBackoff: <duration>
                # Factor for exponential backoff
                backoffFactor: <float>
                # Maximum backoff time
                maxBackoff: <duration>
                # Maximum retry attempts
                maxRetries: <int>
                # Add randomness to wait intervals
                jitter: <bool>                 
              flushInterval: <duration>
              writeBufferSize: <int>
              readBufferSize: <int>
      # Override values for placement
      placementKV:
        zone: <string>
        environment: <string>
        namespace: <string>
      # Placement watcher configuration
      # TODO: Which is?
      placementWatcher:
        # Placement key
        key: <string>
        # Initial watch timeout
        initWatchTimeout: <duration>
      # Hashing type, valid options: [murmu32, zero] 
      hashType: <string>
      shardCutoverWarmupDuration: <duration>
      shardCutoffLingerDuration: <duration>
      # Encoder configuration
      encoder:
        # Initial buffer size
        initBufferSize: <int>
        maxMessageSize: <int>
        # Bucketized pool configuration
        bytesPool:
          # Configuration for a bucket in a pool
          buckets:
            # Number of items in the bucket
            count: <int>
            # Capacity of each item in the bucket
            capacity: <int>
          watermark:
            # The low watermark to start refilling the pool
            # min=0.0, max=1.0
            low: <float>
            # The high watermark to start refilling the pool
            # min=0.0, max=1.0
            high: <float>
      flushSize: <int>
      maxBatchSize: <int>
      maxTimerBatchSize: <int>
      batchFlushDeadline: <duration>
      queueSize: <int>
      queueDropType:
      # Connection configuration
      connection:
        connectionTimeout: <duration>
        connectionKeepAlive: <bool>
        writeTimeout: <duration>
        initReconnectThreshold: <int>
        maxReconnectThreshold: <int>
        reconnectThresholdMultiplier: <int>
        maxReconnectDuration: <duration>
        writeRetries:
          initialBackoff: <duration>
          # Factor for exponential backoff
          backoffFactor: <float>
          # Maximum backoff time
          maxBackoff: <duration>
          # Maximum retry attempts
          maxRetries: <int>
          # Add randomness to wait intervals
          jitter: <bool>                        
  # Aggregation types
  aggregationTypes:
    # Default aggregation types for counter metrics
    defaultCounterAggregationTypes:
    # Default aggregation types for timer metrics
    defaultTimerAggregationTypes:
    # Default aggregation types for gauge metrics
    defaultGaugeAggregationTypes:
    # Configures the type string transformation function for counters, valid options: [noop, empty, suffix]
    counterTransformFnType: 
    # Configures the type string transformation function for timers, valid options: [noop, empty, suffix]
    timerTransformFnType: 
    # Configures the type string transformation function for gauges, valid options: [noop, empty, suffix]
    gaugeTransformFnType: 
    # Pool of aggregation types
    aggregationTypesPool:
      # Size of the pool
      size: <int>
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>
    # Pool of quantile slices.
    quantilesPool:
      buckets:
        - count: 256
          capacity: 4
        - count: 128
          capacity: 8  
  # Pool of counter elements?
  # TODO: ?
  counterElemPool:
  # Pool of timer elements?
  # TODO: ?  
  timerElemPool:
  # Pool of gauge elements?
  # TODO: ?  
  gaugeElemPool:
  # Specifies a custom buffer past limit for aggregation tiles
  bufferPastLimits:
    resolution: <duration>
    bufferPast: <duration>
  # How long an entry remains alive before it is expired due to inactivity
  entryTTL: <duration>
  # Augment the metric type used within the filter for rules
  augmentM3Tags: <bool>
  # Include rollup rules when deciding if the downsampler should ignore auto mapping rules based on the storage polices for a given rule
  includeRollupsOnDefaultRuleFiltering: <bool>

# Ingestion server configuration
ingest:
  ingester:
    workerPoolSize: <int>
    opPool:
    retry:
    logSampleRate: <float>
  m3msg:

# Configuration for the carbon server
# TODO: Which is?
carbon:
  ingester:
  aggregateNamespacesAllData:
  # A constant time to shift start by
  shiftTimeStart: <duration>
  # A constant time to shift end by
  shiftTimeEnd: <duration>
  # A constant set of steps to shift start by
  shiftStepsStart: <int>
  # A constant set of steps to shift end by
  shiftStepsEnd: <int>
  # A constant set of steps to shift start by, if and only if, the end is an exact match to the resolution boundary of a query, and the start is an exact match to the resolution boundary
  shiftStepsStartWhenAtResolutionBoundary: <int>
  # A constant set of steps to shift end by, if and only if, the start is an exact match to the resolution boundary of a query, and the end is an exact match to the resolution boundary
  shiftStepsEndWhenAtResolutionBoundary: <int>
  # A constant set of steps to shift start by, if and only if, the start is an exact match to the resolution boundary of a query, and the end is NOT an exact match to the resolution boundary
  shiftStepsEndWhenStartAtResolutionBoundary: <int>
  # A constant set of steps to shift end by, if and only if, the end is an exact match to the resolution boundary of a query, and the start is NOT an exact match to the resolution boundary
  shiftStepsStartWhenEndAtResolutionBoundary: <int>
  # Render partial datapoints when the start time is between a datapoint's resolution step size
  renderPartialStart: <bool>
  # Render partial datapoints when the end time is between a datapoint's resolution step size
  renderPartialEnd: <bool>
  # Render series that have only NaNs for entire output instead of returning an empty array of datapoints
  renderSeriesAllNaNs: <bool>
  # escape all characters using a backslash in a quoted string instead of only escaping quotes
  compileEscapeAllNotOnlyQuotes: <bool>

# TODO: Query configuration, which is?
query:
  # Query timeout
  timeout: <duration>
  # DefaultEngine is the default query engine.
  # TODO: The what now?
  defaultEngine: <string>
  # Configuration for consolidating fetched queries
  consolidation:
    # Determines the options by which series should match
    # TODO: Need to understand here
    matchType:
  # Prometheus client configuration
  prometheus:
    # The limit on fetched samples per query
    maxSamplesPerQuery: <int>
  # Optional configuration that can be set to restrict all queries with certain tags
  restrictTags:
  # TODO: Fill in
    match:
    strip:

# Specifies limitations on resource usage in the query instance. Limits are split between per-query and global limits
limits:
  # Configures limits on resource usage within a single query. Zero or negative values imply no limit
  perQuery:
    # Limits the number of time series returned for any given individual storage node per query, before returning result to query service
    maxFetchedSeries: <int>
    # Limits the number of index documents matched for any given individual storage node per query, before returning result to query service
    maxFetchedDocs: <int>
    # Generate an error if the query exceeds any limit
    requireExhaustive: <bool>

# Additional configuration for metrics tags
# Read https://m3db.io/docs/how_to/query/#id-generation for more details

# Configuration for shared tag options
# currently only name, but can expand to cover deduplication settings, or other relevant options
tagOptions:
  # TODO: To do…
  # Specifies the tag name that corresponds to the metric's name tag
  # if not provided, defaults to `__name__`
  metricName: <string>
  # Specifies the tag name that corresponds to the metric's bucket
  # if not provided, defaults to 'le'
  bucketName: <string>
  # Determines the default ID generation scheme, valid options: [TypeDefault, TypeQuoted, TypePrependMeta, TypeGraphite]
  # Default TypeQuoted
  # TODO: Details link
  idScheme: <id_scheme>
  # Optional tag filters, removing all series with tags
  # matching the filter from computations.  
  # TODO: What does the above mean?
  # TODO: TBD
  filters:
    values:
    name:
  # Allow for duplicate tags to appear on series
  allowTagNameDuplicates: <bool>
  # Allow for empty tags to appear on series
  allowTagValueEmpty: <bool>

# Sets the lookback duration for queries
# TODO: Which means what?
# Default = 5m
lookbackDuration: <duration>

# The result options for a query
resultOptions:
  # Keeps NaNs before returning query results.
  # Default = false
  keepNans: <bool>

# Configuration for the experimental API group
# TODO: Which is?
experimental: <bool>

# Controls if metrics type stored or not
storeMetricsType: <bool>

# Multi-process configuration
# TODO: Which means?
multiProcess:
  # Enable multi-process execution
  enabled: <bool>
  # The number of sub-processes to run
  # use 0 to auto-detect based on number of CPUs
  count: <int>
  # The factor of processes to run per CPU, leave
  # use 0 to use the default of 0.5 per CPU, i.e. one process for every two CPUs
  # min=0.0, max=1.0
  perCPU: <float>
  # Explicitly sets the child GOMAXPROCs env var
  goMaxProcs: <int>

# TODO:
debug: